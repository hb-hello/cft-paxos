package org.example;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;

import static org.example.ConfigLoader.loadServersFromConfig;

public class Client {
    private static final Logger logger = LogManager.getLogger(Client.class);
    private final String SERVER_DETAILS_FILE_PATH = "src/main/resources/serverDetails.json";
    private final String clientId; // c: self client_id
    private HashMap<String, ServerDetails> servers; // [servers]: Map of all server ids and their connection info
    private String leaderId; // leader: Current leader id
    private final HashMap<String, ManagedChannel> channels; // [channels]: Map of server ids and their gRPC channels
    private final HashMap<String, MessageServiceGrpc.MessageServiceBlockingStub> stubs; // [stubs]: Map of server ids and their gRPC stubs
    //    private final HashMap<String, MessageServiceOuterClass.ClientReply> history; // [history]: Map of old requests sent and replies received - #TODO Create a record for each history item

    public Client(String clientId) {
        this.clientId = clientId;
        this.channels = new HashMap<>();
        this.stubs = new HashMap<>();
        this.servers = new HashMap<>();
        this.leaderId = null;

        try {
            this.servers = loadServersFromConfig(SERVER_DETAILS_FILE_PATH);
        } catch (Exception e) {
            logger.error("Client {}: Failed to load server details from default config file {} : {}", clientId, SERVER_DETAILS_FILE_PATH, e.getMessage());
            throw new RuntimeException(e);
        }
    }

    public Client(String clientId, String serverDetailsFilePath) {
        this.clientId = clientId;
        this.channels = new HashMap<>();
        this.stubs = new HashMap<>();
        this.servers = new HashMap<>();
        this.leaderId = null;

        try {
            this.servers = loadServersFromConfig(serverDetailsFilePath);
        } catch (Exception e) {
            logger.error("Client {}: Failed to load server details from user-provided config file {} : {}", clientId, serverDetailsFilePath, e.getMessage());
            throw new RuntimeException(e);
        }
    }

    public String getLeaderId() {
        return leaderId;
    }

    /**
     * Generates a ClientRequest proto message.
     *
     * @param transaction The transaction object (from the class generated by grpc)
     * @return ClientRequest proto message
     */
    static MessageServiceOuterClass.ClientRequest generateClientRequest(MessageServiceOuterClass.Transaction transaction) {
        long timestamp = System.currentTimeMillis();
        return MessageServiceOuterClass.ClientRequest.newBuilder().setTransaction(transaction).setTimestamp(timestamp).setClientId(transaction.getSender()).build();
    }

//    Channel management methods

    private ManagedChannel createChannel(String serverId) {
        if (!servers.containsKey(serverId)) {
            logger.error("Client {}: Server ID {} not found in configuration.", clientId, serverId);
            throw new RuntimeException();
        }
        ServerDetails server = servers.get(serverId);
        ManagedChannel channel = ManagedChannelBuilder.forAddress(server.host(), server.port()).usePlaintext().build();
        channels.put(serverId, channel);
        logger.info("Client {}: Initialized gRPC channel to server {} at {}:{}", clientId, serverId, server.host(), server.port());
        return channel;
    }

    private void shutdownChannels() {
        for (Map.Entry<String, ManagedChannel> entry : channels.entrySet()) {
            String serverId = entry.getKey();
            ManagedChannel channel = entry.getValue();
            if (channel != null && !channel.isShutdown()) {
                channel.shutdown();
                logger.info("Client {}: Shutdown gRPC channel to server {}", clientId, serverId);
            }
        }
    }

    private ManagedChannel createOrGetChannel(String serverId) {
        if (channels.containsKey(serverId)) {
            return channels.get(serverId);
        }
        return createChannel(serverId);
    }

//    Stub management methods

    private MessageServiceGrpc.MessageServiceBlockingStub createStub(String serverId) {
        ManagedChannel channel = createOrGetChannel(serverId);
        MessageServiceGrpc.MessageServiceBlockingStub stub = MessageServiceGrpc.newBlockingStub(channel);
        stubs.put(serverId, stub);
        logger.info("Client {}: Initialized gRPC stub for server {}", clientId, serverId);
        return stub;
    }


    /**
     * @param serverId The target server's ID
     * @return The blocking stub for the specified server, creating it if it doesn't already exist
     */
    private MessageServiceGrpc.MessageServiceBlockingStub createOrGetStub(String serverId) {
        if (stubs.containsKey(serverId)) {
            return stubs.get(serverId);
        }
        return createStub(serverId);
    }

    /**
     * Sends a ClientRequest to the specified server using a provided gRPC ManagedChannel, waits for a response with a timeout,
     * and retries if no response is received. Retries up to maxRetries times.
     *
     * @param request       The ClientRequest to send
     * @param serverId      The target server's ID (for logging only)
     * @param timeoutMillis Timeout in milliseconds to wait for a response
     * @param maxRetries    Maximum number of retries if no response is received
     * @return The server's response, or null if all retries fail
     */
    private MessageServiceOuterClass.ClientReply sendClientRequestWithRetry(MessageServiceOuterClass.ClientRequest request, String serverId, long timeoutMillis, int maxRetries) {
        int attempt = 0;
        while (attempt <= maxRetries) {
            attempt++;
            try (ExecutorService executor = Executors.newSingleThreadExecutor()) {
                MessageServiceGrpc.MessageServiceBlockingStub stub = createOrGetStub(serverId);
                logger.info("Client {}: Sending ClientRequest to server {} (attempt {}/{})", clientId, serverId, attempt, maxRetries + 1);
                Future<MessageServiceOuterClass.ClientReply> future = executor.submit(() -> stub.request(request));
                try {
                    MessageServiceOuterClass.ClientReply reply = future.get(timeoutMillis, TimeUnit.MILLISECONDS);
                    logger.info("Client {}: Received reply from server {}: {}", clientId, serverId, reply);
                    return reply;
                } catch (TimeoutException e) {
                    logger.warn("Client {}: Timeout waiting for reply from server {} (attempt {}/{}). Retrying...", clientId, serverId, attempt, maxRetries + 1);
                    future.cancel(true);
                } catch (ExecutionException | InterruptedException e) {
                    logger.error("Client {}: Error while waiting for reply from server {}: {}", clientId, serverId, e.getMessage());
                }
            } catch (StatusRuntimeException e) {
                logger.error("Client {}: gRPC error communicating with server {}: {}", clientId, serverId, e.getMessage());
            }
        }
        logger.error("Client {}: Failed to receive reply from server {} after {} attempts.", clientId, serverId, maxRetries + 1);
        return null;
    }

    public void processTransaction(MessageServiceOuterClass.Transaction transaction, long timeoutMillis, int maxRetries) {
        MessageServiceOuterClass.ClientRequest request = generateClientRequest(transaction);
        if (leaderId == null) {
            parseServerReply(broadcastRequest(request, timeoutMillis, maxRetries));
        } else {
            parseServerReply(sendClientRequestWithRetry(request, leaderId, timeoutMillis, maxRetries));
        }
    }

    private void parseServerReply(MessageServiceOuterClass.ClientReply reply) {
        if (reply != null) {
            if (reply.getResult()) logger.info("Client {}: Transaction successful.", clientId);
            else logger.info("Client {}: Transaction failed.", clientId);
            this.leaderId = reply.getSenderId();
            logger.info("Client {}: Updated leader ID to node {}.", clientId, leaderId);
        } else {
            this.leaderId = null;
            logger.error("Client {}: Client received no reply.", clientId);
        }
    }

    private MessageServiceOuterClass.ClientReply broadcastRequest(MessageServiceOuterClass.ClientRequest request, long timeoutMillis, int maxRetries) {

        int serverCount = servers.size();

        try (ExecutorService executor = Executors.newFixedThreadPool(serverCount)) {
            CompletionService<MessageServiceOuterClass.ClientReply> completionService = new ExecutorCompletionService<>(executor);
            for (final String serverId : servers.keySet()) {
                completionService.submit(new SendRequestCallable(request, serverId, timeoutMillis, maxRetries));
            }

            for (int i = 0; i < serverCount; i++) {
                Future<MessageServiceOuterClass.ClientReply> future = completionService.take();
                try {
//                    Return the very first reply from the broadcast
//                    TODO: Grab replies from all threads and check if all are consistent
                    executor.shutdownNow(); // Do I need this here?
                    return future.get();
                } catch (InterruptedException | ExecutionException e) {
                    logger.error("Client {}: Error while waiting for broadcast reply.", clientId, e);
                    throw new RuntimeException(e);
                }
            }
        } catch (Exception e) {
            logger.error("Client {}: Error in spawning multiple threads for broadcast", clientId, e);
        }

        return null;

    }

    private class SendRequestCallable implements Callable<MessageServiceOuterClass.ClientReply> {

        MessageServiceOuterClass.ClientRequest request;
        String serverId;
        long timeoutMillis;
        int maxRetries;

        public SendRequestCallable(MessageServiceOuterClass.ClientRequest request, String serverId, long timeoutMillis, int maxRetries) {
            this.request = request;
            this.serverId = serverId;
            this.timeoutMillis = timeoutMillis;
            this.maxRetries = maxRetries;
        }

        @Override
        public MessageServiceOuterClass.ClientReply call() throws Exception {
            try {
                logger.info("Client {}: Broadcasting request to server {}.", clientId, serverId);
                return sendClientRequestWithRetry(request, serverId, timeoutMillis, maxRetries);
            } catch (Exception e) {
                logger.error("Client {}: Error broadcasting request to server {} : {}", clientId, serverId, e.getMessage());
            }
            return null;
        }
    }

    public static void main(String[] args) {

//        Wrap in try-with-resources statement to ensure proper shutdown

//        try (ExecutorService executor = Executors.newFixedThreadPool(clientIds.length)) {
//            for (final String clientId : clientIds) {
//                executor.submit(() -> {
//                    try {
//                        Client client = new Client();
//                        logger.info("CClient {}: lient initialized");
//                        long timestamp = System.currentTimeMillis();
//                        MessageServiceOuterClass.ClientRequest request = generateClientRequest(clientId, "B", 10.0, timestamp);
//                        MessageServiceOuterClass.ClientReply reply = client.sendClientRequestWithRetry(request, "1", 500, 2);
//                    } catch (Exception e) {
//                        logger.error("EClient {}: rror initializing client {} : {}", e.getMessage());
//                    }
//                });
//            }
//        } catch (Exception e) {
//            logger.error("EClient {}: rror in spawning multiple threads for clients : {}", e.getMessage());
//        }

    }

}