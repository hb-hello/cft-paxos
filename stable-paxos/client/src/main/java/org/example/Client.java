package org.example;

import com.google.protobuf.Empty;
import io.grpc.ManagedChannel;
import io.grpc.StatusRuntimeException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.*;

import static org.example.ChannelManager.createOrGetChannel;

public class Client {
    private static final Logger logger = LogManager.getLogger(Client.class);
    private final String clientId; // c: self client_id
    private Map<String, ServerDetails> servers; // [servers]: Map of all server ids and their connection info
    private String leaderId; // leader: Current leader id
    private final HashMap<String, ManagedChannel> channels; // [channels]: Map of server ids and their gRPC channels
    private final HashMap<String, MessageServiceGrpc.MessageServiceBlockingStub> stubs; // [stubs]: Map of server ids and their gRPC stubs
    //    private final HashMap<String, MessageServiceOuterClass.ClientReply> history; // [history]: Map of old requests sent and replies received - #TODO Create a record for each history item
    private final ExecutorService networkExecutor;

    public Client(String clientId) {
        this.clientId = clientId;
        this.channels = ChannelManager.getChannels(null);
        this.stubs = new HashMap<>();
        this.servers = new HashMap<>();
        this.leaderId = "n1";


        try {
            this.servers = Config.getServers();
            this.networkExecutor = Executors.newCachedThreadPool(); // Thread pool for handling network operations
        } catch (Exception e) {
//            logger.error("Client {}: Failed to load server details from path defined in config.properties : {}", clientId, e.getMessage());
            throw new RuntimeException(e);
        }
    }

    public String getLeaderId() {
        return leaderId;
    }

    /**
     * Generates a ClientRequest proto message.
     *
     * @param transaction The transaction object (from the class generated by grpc)
     * @return ClientRequest proto message
     */
    static MessageServiceOuterClass.ClientRequest generateClientRequest(MessageServiceOuterClass.Transaction transaction) {
        long timestamp = System.currentTimeMillis();
        return MessageServiceOuterClass.ClientRequest.newBuilder().setTransaction(transaction).setTimestamp(timestamp).setClientId(transaction.getSender()).build();
    }

//    Stub management methods

    private MessageServiceGrpc.MessageServiceBlockingStub createStub(String serverId) {
        ManagedChannel channel = channels.get(serverId);
        MessageServiceGrpc.MessageServiceBlockingStub stub = MessageServiceGrpc.newBlockingStub(channel);
        stubs.put(serverId, stub);
//        logger.info("Client {}: Initialized gRPC stub for server {}", clientId, serverId);
        return stub;
    }

    /**
     * @param serverId The target server's ID
     * @return The blocking stub for the specified server, creating it if it doesn't already exist
     */
    private MessageServiceGrpc.MessageServiceBlockingStub createOrGetStub(String serverId) {
        if (stubs.containsKey(serverId)) {
            return stubs.get(serverId);
        }
        return createStub(serverId);
    }

    // Leader failure

    public static void broadcastFailLeader() {
        Map<String, ServerDetails> servers = Config.getServers();

        for (String serverId : servers.keySet()) {
            try {
                ManagedChannel channel = createOrGetChannel(serverId);
                MessageServiceGrpc.MessageServiceBlockingStub stub = MessageServiceGrpc.newBlockingStub(channel);
                MessageServiceOuterClass.Acknowledgement ack = stub.failLeader(Empty.getDefaultInstance());
                if (ack.getStatus()) {
//                    System.out.println("Server " + serverId + " acknowledged leader failure.");
                    break; // Exit loop on first successful acknowledgment
                } else {
//                    System.err.println("Server " + serverId + " failed to acknowledge leader failure.");
                }
            } catch (RuntimeException e) {
                System.err.println("Error when sending failLeader to server " + serverId + ": " + e.getMessage());
            }
        }
    }

//    Client request methods

    // Send client request once with timeout
    private MessageServiceOuterClass.ClientReply sendClientRequestWithTimeout(MessageServiceOuterClass.ClientRequest request, String serverId) {
        try {
            MessageServiceGrpc.MessageServiceBlockingStub stub = createOrGetStub(serverId);
            logger.info("Client {}: Sending ClientRequest ({}, {}, {}) to server {} with timeout {} ms", clientId,
                    request.getTransaction().getSender(), request.getTransaction().getReceiver(), request.getTransaction().getAmount(), serverId, Config.getClientTimeoutMillis());
            MessageServiceOuterClass.ClientReply reply = stub.withDeadlineAfter(Config.getClientTimeoutMillis(), TimeUnit.MILLISECONDS).request(request);
//            logger.info("Client {}: Received reply from server {}: {}", clientId, serverId, reply);
            return reply;
        } catch (StatusRuntimeException e) {
            logger.error("Client {}: gRPC error when sending request one node communicating with server {} for request ({}, {}, {}): {}", clientId, request.getTransaction().getSender(), request.getTransaction().getReceiver(), request.getTransaction().getAmount(), serverId, e.getMessage());
        }
        return null;
    }

    public void processTransaction(MessageServiceOuterClass.Transaction transaction) {
        MessageServiceOuterClass.ClientRequest request = generateClientRequest(transaction);

        boolean retry = true;

        while(retry) {
            if (leaderId != null) {
                if (parseServerReply(sendClientRequestWithTimeout(request, leaderId))) {
                    retry = false;
                } else {
                    logger.info("Client {}: Retrying transaction with broadcast due to failed reply from leader {}", clientId, leaderId);
                }
            } else {
//                logger.info("Client {}: No known leader. Broadcasting request.", clientId);
                if (parseServerReply(broadcastRequest(request))) {
                    retry = false;
                } else {
                    logger.info("Client {}: Retrying transaction with broadcast due to no replies.", clientId);
                }
            }
        }

        logger.info("Client {}: Processed transaction: ({}, {}, {})", clientId, transaction.getSender(), transaction.getReceiver(), transaction.getAmount());
    }

    private boolean parseServerReply(MessageServiceOuterClass.ClientReply reply) {
        if (reply != null) {
            if (reply.getResult()) {
                logger.info("Client {}: Transaction successful.", clientId);
                this.leaderId = reply.getSenderId();
//                logger.info("Client {}: Updated leader ID to node {}.", clientId, leaderId);
            }
            else logger.info("Client {}: Transaction failed.", clientId);
            return true;
        } else {
            this.leaderId = null;
//            logger.error("Client {}: Client received no reply.", clientId);
            return false;
        }
    }

    private MessageServiceOuterClass.ClientReply broadcastRequest(MessageServiceOuterClass.ClientRequest request) {

        int serverCount = servers.size();

        try {
            CompletionService<MessageServiceOuterClass.ClientReply> completionService = new ExecutorCompletionService<>(networkExecutor);
            for (final String serverId : servers.keySet()) {
                completionService.submit(new SendRequestCallable(request, serverId));
            }

            for (int i = 0; i < serverCount; i++) {
                Future<MessageServiceOuterClass.ClientReply> future = completionService.take();
                try {
//                    Return the very first reply from the broadcast
//                    networkExecutor.shutdownNow(); // Do I need this here?
                    return future.get();
                } catch (InterruptedException | ExecutionException e) {
//                    logger.error("Client {}: Error while waiting for broadcast reply.", clientId, e);
                    throw new RuntimeException(e);
                }
            }
        } catch (Exception e) {
            logger.error("Client {}: Error in spawning multiple threads for broadcast", clientId, e);
        }

        return null;
    }

    private class SendRequestCallable implements Callable<MessageServiceOuterClass.ClientReply> {

        MessageServiceOuterClass.ClientRequest request;
        String serverId;

        public SendRequestCallable(MessageServiceOuterClass.ClientRequest request, String serverId) {
            this.request = request;
            this.serverId = serverId;
        }

        @Override
        public MessageServiceOuterClass.ClientReply call() throws Exception {
            try {
                logger.info("Client {}: Broadcasting request ({}, {}, {}) to server {}.", clientId, request.getTransaction().getSender(), request.getTransaction().getReceiver(), request.getTransaction().getAmount(), serverId);
                return sendClientRequestWithTimeout(request, serverId);
            } catch (Exception e) {
                logger.error("Client {}: Error broadcasting request to server {} : {}", clientId, serverId, e.getMessage());
            }
            return null;
        }
    }

    public static void main(String[] args) {

//        Wrap in try-with-resources statement to ensure proper shutdown

//        try (ExecutorService executor = Executors.newFixedThreadPool(clientIds.length)) {
//            for (final String clientId : clientIds) {
//                executor.submit(() -> {
//                    try {
//                        Client client = new Client();
////                        logger.info("CClient {}: lient initialized");
//                        long timestamp = System.currentTimeMillis();
//                        MessageServiceOuterClass.ClientRequest request = generateClientRequest(clientId, "B", 10.0, timestamp);
//                        MessageServiceOuterClass.ClientReply reply = client.sendClientRequestWithRetry(request, "1", 500, 2);
//                    } catch (Exception e) {
////                        logger.error("EClient {}: rror initializing client {} : {}", e.getMessage());
//                    }
//                });
//            }
//        } catch (Exception e) {
////            logger.error("EClient {}: rror in spawning multiple threads for clients : {}", e.getMessage());
//        }

    }

}