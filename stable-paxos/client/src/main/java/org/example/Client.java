package org.example;

import io.grpc.ManagedChannel;
import io.grpc.StatusRuntimeException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.*;

import static org.example.ChannelManager.createOrGetChannel;
import static org.example.Config.getMaxRetries;

public class Client {
    private static final Logger logger = LogManager.getLogger(Client.class);
    private final String clientId; // c: self client_id
    private Map<String, ServerDetails> servers; // [servers]: Map of all server ids and their connection info
    private String leaderId; // leader: Current leader id
    private final HashMap<String, ManagedChannel> channels; // [channels]: Map of server ids and their gRPC channels
    private final HashMap<String, MessageServiceGrpc.MessageServiceBlockingStub> stubs; // [stubs]: Map of server ids and their gRPC stubs
    //    private final HashMap<String, MessageServiceOuterClass.ClientReply> history; // [history]: Map of old requests sent and replies received - #TODO Create a record for each history item

    public Client(String clientId) {
        this.clientId = clientId;
        this.channels = new HashMap<>();
        this.stubs = new HashMap<>();
        this.servers = new HashMap<>();
        this.leaderId = "n1";

        try {
            this.servers = Config.getServers();
        } catch (Exception e) {
            logger.error("Client {}: Failed to load server details from path defined in config.properties : {}", clientId, e.getMessage());
            throw new RuntimeException(e);
        }
    }

    public String getLeaderId() {
        return leaderId;
    }

    /**
     * Generates a ClientRequest proto message.
     *
     * @param transaction The transaction object (from the class generated by grpc)
     * @return ClientRequest proto message
     */
    static MessageServiceOuterClass.ClientRequest generateClientRequest(MessageServiceOuterClass.Transaction transaction) {
        long timestamp = System.currentTimeMillis();
        return MessageServiceOuterClass.ClientRequest.newBuilder().setTransaction(transaction).setTimestamp(timestamp).setClientId(transaction.getSender()).build();
    }


//    Stub management methods

    private MessageServiceGrpc.MessageServiceBlockingStub createStub(String serverId) {
        ManagedChannel channel = createOrGetChannel(serverId);
        MessageServiceGrpc.MessageServiceBlockingStub stub = MessageServiceGrpc.newBlockingStub(channel);
        stubs.put(serverId, stub);
        logger.info("Client {}: Initialized gRPC stub for server {}", clientId, serverId);
        return stub;
    }

    /**
     * @param serverId The target server's ID
     * @return The blocking stub for the specified server, creating it if it doesn't already exist
     */
    private MessageServiceGrpc.MessageServiceBlockingStub createOrGetStub(String serverId) {
        if (stubs.containsKey(serverId)) {
            return stubs.get(serverId);
        }
        return createStub(serverId);
    }

    /**
     * Sends a ClientRequest to the specified server using a provided gRPC ManagedChannel, waits for a response with a timeout,
     * and retries if no response is received. Retries up to maxRetries times.
     *
     * @param request       The ClientRequest to send
     * @param serverId      The target server's ID (for logging only)
     * @return The server's response, or null if all retries fail
     */
    private MessageServiceOuterClass.ClientReply sendClientRequestWithRetry(MessageServiceOuterClass.ClientRequest request, String serverId) {
        int maxRetries = Config.getMaxRetries();
        long timeoutMillis = Config.getClientTimeoutMillis();

        int attempt = 0;

        while (attempt <= maxRetries) {
            attempt++;
//            Creating a thread to enforce timeout using future.get
            try (ExecutorService executor = Executors.newSingleThreadExecutor()) {
                MessageServiceGrpc.MessageServiceBlockingStub stub = createOrGetStub(serverId);
                logger.info("Client {}: Sending ClientRequest to server {} (attempt {}/{})", clientId, serverId, attempt, maxRetries + 1);
                Future<MessageServiceOuterClass.ClientReply> future = executor.submit(() -> stub.request(request));
                try {
                    MessageServiceOuterClass.ClientReply reply = future.get(timeoutMillis, TimeUnit.MILLISECONDS);
                    logger.info("Client {}: Received reply from server {}: {}", clientId, serverId, reply);
                    return reply;
                } catch (TimeoutException e) {
                    logger.warn("Client {}: Timeout waiting for reply from server {} (attempt {}/{}). Retrying...", clientId, serverId, attempt, maxRetries + 1);
                    future.cancel(true);
                } catch (ExecutionException | InterruptedException e) {
                    logger.error("Client {}: Error while waiting for reply from server {}: {}", clientId, serverId, e.getMessage());
                }
            } catch (StatusRuntimeException e) {
                logger.error("Client {}: gRPC error communicating with server {}: {}", clientId, serverId, e.getMessage());
            }
        }
        logger.error("Client {}: Failed to receive reply from server {} after {} attempts.", clientId, serverId, maxRetries + 1);
        return null;
    }

    public void processTransaction(MessageServiceOuterClass.Transaction transaction) {
        MessageServiceOuterClass.ClientRequest request = generateClientRequest(transaction);
        if (leaderId == null) {
            parseServerReply(broadcastRequest(request));
        } else {
            parseServerReply(sendClientRequestWithRetry(request, leaderId));
        }
        logger.info("Client {}: Processed transaction: ({}, {}, {})", clientId, transaction.getSender(), transaction.getReceiver(), transaction.getAmount());
    }

    private void parseServerReply(MessageServiceOuterClass.ClientReply reply) {
        if (reply != null) {
            if (reply.getResult()) {
                logger.info("Client {}: Transaction successful.", clientId);
                this.leaderId = reply.getSenderId();
                logger.info("Client {}: Updated leader ID to node {}.", clientId, leaderId);
            }
            else logger.info("Client {}: Transaction failed.", clientId);
        } else {
            this.leaderId = null;
            logger.error("Client {}: Client received no reply.", clientId);
        }
    }

    private MessageServiceOuterClass.ClientReply broadcastRequest(MessageServiceOuterClass.ClientRequest request) {

        int serverCount = servers.size();

        try (ExecutorService executor = Executors.newFixedThreadPool(serverCount)) {
            CompletionService<MessageServiceOuterClass.ClientReply> completionService = new ExecutorCompletionService<>(executor);
            for (final String serverId : servers.keySet()) {
                completionService.submit(new SendRequestCallable(request, serverId));
            }

            for (int i = 0; i < serverCount; i++) {
                Future<MessageServiceOuterClass.ClientReply> future = completionService.take();
                try {
//                    Return the very first reply from the broadcast
//                    TODO: Grab replies from all threads and check if all are consistent
                    executor.shutdownNow(); // Do I need this here?
                    return future.get();
                } catch (InterruptedException | ExecutionException e) {
                    logger.error("Client {}: Error while waiting for broadcast reply.", clientId, e);
                    throw new RuntimeException(e);
                }
            }
        } catch (Exception e) {
            logger.error("Client {}: Error in spawning multiple threads for broadcast", clientId, e);
        }

        return null;

    }

    private class SendRequestCallable implements Callable<MessageServiceOuterClass.ClientReply> {

        MessageServiceOuterClass.ClientRequest request;
        String serverId;

        public SendRequestCallable(MessageServiceOuterClass.ClientRequest request, String serverId) {
            this.request = request;
            this.serverId = serverId;
        }

        @Override
        public MessageServiceOuterClass.ClientReply call() throws Exception {
            try {
                logger.info("Client {}: Broadcasting request to server {}.", clientId, serverId);
                return sendClientRequestWithRetry(request, serverId);
            } catch (Exception e) {
                logger.error("Client {}: Error broadcasting request to server {} : {}", clientId, serverId, e.getMessage());
            }
            return null;
        }
    }

    public static void main(String[] args) {

//        Wrap in try-with-resources statement to ensure proper shutdown

//        try (ExecutorService executor = Executors.newFixedThreadPool(clientIds.length)) {
//            for (final String clientId : clientIds) {
//                executor.submit(() -> {
//                    try {
//                        Client client = new Client();
//                        logger.info("CClient {}: lient initialized");
//                        long timestamp = System.currentTimeMillis();
//                        MessageServiceOuterClass.ClientRequest request = generateClientRequest(clientId, "B", 10.0, timestamp);
//                        MessageServiceOuterClass.ClientReply reply = client.sendClientRequestWithRetry(request, "1", 500, 2);
//                    } catch (Exception e) {
//                        logger.error("EClient {}: rror initializing client {} : {}", e.getMessage());
//                    }
//                });
//            }
//        } catch (Exception e) {
//            logger.error("EClient {}: rror in spawning multiple threads for clients : {}", e.getMessage());
//        }

    }

}